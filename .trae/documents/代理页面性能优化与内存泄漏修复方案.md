## 问题诊断

- 大量代理节点渲染：`ProxyList` 将所有节点一次性渲染为网格，导致 DOM 节点极多与样式计算、布局和绘制开销巨大（src/components/proxies/ProxyList.tsx:15）。
- 频繁重渲染来源：
  - 每次 `fetchProxies` 会重建 `proxies` 映射，导致所有已连接的子项（`Proxy`/`ProxySmall`）因 props 引用变化而重渲染（src/store/proxies.tsx:55-93，src/components/proxies/Proxy.tsx:250-259）。
  - 自定义 `connect` 的实现会在全局状态改变时执行 `mapStateToProps`，如所选字段引用变化则即使 React.memo 也会重渲染（src/components/StateProvider.tsx:67-76）。
- iOS Safari/Chrome 卡顿：移动端滚动合成线程切换频繁，网格布局（CSS Grid）与大量 tooltip/交互事件叠加加剧主线程压力（src/components/proxies/ProxyList.module.scss:3-19，src/components/proxies/Proxy.tsx:141-154）。
- 可能的内存泄漏：
  - 日志 WebSocket 在离开日志页后仍保持连接，未在组件卸载时显式关闭（src/components/Logs.tsx:58-61，src/api/logs.ts:95-120）。
  - 流量与内存数据 WebSocket 在订阅者为 0 时未关闭，底层连接可能持续存在（src/api/traffic.ts:79-95，src/api/memory.ts:78-95）。
  - 连接页 WebSocket 仅维护订阅者列表，未在订阅者清零时主动关闭连接（src/api/connections.ts:71-103, 105-111）。

## 优化目标

- 代理页在数千节点时仍保持流畅滚动与选择；节点切换交互无明显卡顿。
- 降低不必要的重渲染与排序/过滤的计算开销。
- 清理各页面的长连接与事件监听，杜绝离开页面后资源未释放的情况。

## 实施方案

### 1. 代理列表虚拟化

- 引入 `react-window`（已在依赖中，package.json:34-35）以网格虚拟化渲染：使用 `FixedSizeGrid` 替换 `ProxyList` 与 `ProxyListSummaryView` 的全量 map 渲染（src/components/proxies/ProxyList.tsx:15-33, 35-56）。
- 计算列数与容器尺寸：复用 `ProxyGroupImpl` 中的 `windowWidth` 状态（src/components/proxies/ProxyGroup.tsx:89-99, 100-108）与每项固定尺寸（例如 Detail 卡片高度约 64px、最小宽度 200px；Summary 点高度/宽度 15px）。
- 阈值策略：当 `all.length > 200` 或检测到 iOS 设备时启用虚拟化，小列表维持现状以降低复杂度。

### 2. 减少重复渲染

- 精简 `mapStateToProps` 输出：避免传递整条 `proxy` 引用（`proxies[name]`），改为传递所需的稳定字段（类型、UDP/XUDP/TFO 标志、最新 delay 数值），降低因对象引用变化导致的渲染（src/components/proxies/Proxy.tsx:250-259, 165-246）。
- 为 `Proxy` 与 `ProxySmall` 添加自定义 `React.memo` 比较函数，仅当 `now`、`latency.number` 或少量展示字段变化时才重渲染。
- 过滤/排序稳定化：`useFilteredAndSorted` 内部已做 `useMemo` 与 300ms 防抖（src/components/proxies/hooks.tsx:113-133，src/hooks/useTextInput.ts:12-19），但对大数组排序的 `.sort` 会原地变更；复制输入数组后排序已存在（src/components/proxies/hooks.tsx:101-111），保留此策略并在虚拟化后总体渲染压力显著下降。

### 3. 交互优化（切换节点）

- 在 `switchProxy` 内对 `dispatch(fetchProxies(apiConfig))` 使用 `React.startTransition` 包裹，降低主线程阻塞（src/store/proxies.tsx:254-267）。
- 延迟全量刷新：维持现有乐观更新（src/store/proxies.tsx:259-266），将刷新置于低优先级任务；如必要增加设置项允许禁用切换后的立即全量刷新。

### 4. 样式与滚动性能

- 为滚动容器与卡片添加合成层与硬件加速提示：在列表容器上设置 `will-change: transform` 与 `contain: layout paint`；卡片交互（hover/scale）尽量使用 `transform` 而非影响布局的属性（src/components/proxies/Proxy.module.scss:35-41, 79-105）。
- 移动端优化：在 iOS 下减少 tooltip 的使用或改为延迟挂载，避免大量浮层参与重排（src/components/proxies/Proxy.tsx:141-154）。

### 5. 内存泄漏排查与修复

- 日志：在日志组件卸载时关闭 WebSocket 与中止流式 fetch；在 `useEffect` 返回中调用 `stopLogs()`（src/components/Logs.tsx:58-61，src/api/logs.ts:109-112）。
- 流量/内存：
  - 在模块作用域维护 `ws` 引用与订阅者计数；当 `unsubscribe` 使订阅者数量归零时调用 `ws.close()` 并重置状态（src/api/traffic.ts:79-95，src/api/memory.ts:78-95）。
  - 确保在 `fetchDataWithFetch` 模式下 `ReadableStream` reader 结束时释放引用（已有），同时清理订阅者列表。
- 连接页：在 `subscribe` 的 `unsubscribe` 中，当订阅者长度为 0 时主动 `ws.close()`（src/api/connections.ts:105-111, 86-97）。并确保 `fetchData` 的 `useEffect` 返回值由 API 提供的 `unsubscribe` 完整释放（src/components/Connections.tsx:341-347）。

### 6. 监控与排查工具

- 在开发模式为代理页关键区域包裹 `React.Profiler`，记录渲染次数与耗时。
- 添加轻量统计：滚动时每 500ms 记录可见项数量与平均渲染时间，输出到控制台用于对比虚拟化前后差异。

## 验证计划

- 本地构造 2k/5k/10k 节点数据，比较滚动 FPS 与首屏渲染耗时。
- 切换节点压力测试：连续切换 50 次，观察 UI 响应与 CPU 占用。
- 页面切换资源释放：进入/离开日志、流量、内存、连接页后，使用浏览器性能工具确认 WebSocket/ReadableStream 已断开，事件监听数量无增长。

## 兼容与回滚

- 虚拟化有阈值与设备判断，低数据量时保持原体验；如遇布局问题可通过开关禁用。
- 保留旧渲染路径，出现异常时快速回滚到原列表渲染。

## 风险与注意

- 网格虚拟化需固定项尺寸；若卡片高度差异较大需切换为 `VariableSizeGrid` 或统一卡片高度。
- Tooltip 与键盘交互在虚拟化场景需绑定到行元素上，确保可访问性。
- WebSocket 关闭逻辑需谨慎处理竞态，避免反复重连与抖动。
